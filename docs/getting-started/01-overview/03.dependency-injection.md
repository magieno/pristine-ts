<p>
   <strong>Previous section: </strong> <a href="02.hosting.md">Hosting</a>
</p>


# Dependency Injection

Dependency Injection is a software pattern where your dependencies are "injected" into your class. This means that you don't when you are in your class, you don't have to worry about how your dependencies will be instantiated. 
You just know they will be instantiated for you.

This is a very strong pattern for testing. It's very easy to mock the dependencies if you specify your dependencies as Interfaces. Then, your mocks simply have to implement the Interface and there you go. This allows you to unit test
your class in complete isolation.

If you want to read more about Dependency Injection, here are a few links:
* [A quick intro to Dependency Injection: what it is, and when to use it](https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/)
* [https://blog.logrocket.com/the-perfect-architecture-flow-for-your-next-node-js-project/](https://blog.logrocket.com/the-perfect-architecture-flow-for-your-next-node-js-project/) 

## Dependency Injection in NodeJS, really?
Dependency Injection is not always popular in NodeJS. There's a big debate going on between whether you should need DI since you can import your classes (that you could be instantiated exported). In our opinion though, this still creates a tight coupling between classes. Also, testing is way harder without DI.

Similar to the approach that [NestJS](https://github.com/nestjs/nest) has taken, we are going full Object Oriented Programming with Dependency Injection at its core.

## TSyringe to the rescue

We haven't reinvented the wheel so Pristine uses [TSyringe](https://github.com/microsoft/tsyringe), developed by Microsoft, as a Dependency Injection container. If you want to access the TSyringe container, simply get it from the kernel:

```
kernel.container
```

### Registering dependencies

There are a few ways to register your dependencies. The most recommended way is to annotate your class with the `@injectable()` decorator as described in TSyringe's documentation. Here's an example:

```
@injectable()
class DatabaseService {
}

@injectable()
class MyService {
    public constructor(private readonly databaseService: DatabaseService) {}    
}
```

**Take note**, in order for Pristine and TSyringe to find your class and register it, due to the fact decorators do not get called if no classes are importing it, you must also register any services in your module class like this:

```
export const AppModule: AppModuleInterface = {
    importServices: [
        DatabaseService, // <-- Must be registered here to be found
        MyService, // <-- Must be registered here to be found
    ],
    importModules: [
     CoreModule,
    ],
    keyname: "my_namespace.app",
}
```

#### The @tag decorator
Even though TSyringe offers a vast range of functionalities, there's one that is missing. The ability to be injected multiple classes as an array of dependencies. Let's say you want to do something like this:

```
interface LogHandler {
    log(message: string);
}

@injectable()
class FileLogHandler implements LogHandler {
    log(message: string) {
        // save the message to a file
    }
}

@injectable()
class ConsoleLogHandler implements LogHandler {
    log(message: string) {
        console.log(message);
    }
}

@injectable()
class Logger {
    constructor(private readonly logHandlers: LogHandlerInterface[]) {} // <-- It would be nice to be able to have all the classes that implement LogHandler 
}

```

That's where the `@tag` decorator comes into play. You annotate the classes that you want to "tag" and then, you use the `@injectAll` decorator to receive all the classes that have been tagged. Here's how the previous code would look like:

**The tag name inside the `@tag` decorator must be unique else you will get a unexpected list of classes**

```
interface LogHandler {
    log(message: string);
}

@tag("LogHandler")
@injectable()
class FileLogHandler implements LogHandler {
    log(message: string) {
        // save the message to a file
    }
}

@tag("LogHandler")
@injectable()
class ConsoleLogHandler implements LogHandler {
    log(message: string) {
        console.log(message);
    }
}

@injectable()
class Logger {
    constructor(@injectAll("LogHandler") private readonly logHandlers: LogHandlerInterface[]) {} // <-- It would be nice to be able to have all the classes that implement LogHandler 
}

```

**Side note, due to how TSyringe works, if you use `@injectAll` and there are no classes, TSryinge will throw. Therefore, if you use `@injectAll`, makes sure at least one of your class has the `@tag` decorator.**

#### The @moduleScoped decorator
The `@moduleScoped` only works if you have the `@tag` decorator also on the class. The `@moduleScoped` is particularly useful if you have multiple modules. 

Sometimes, it can happen that classes in your module are imported in other services but you decide to not import the module. The `@tag` decorator would still load the module and you would wonder why since you are not importing the module.

Therefore, it's highly recommended adding `@moduleScoped` and pass the module keyname as a parameter to ensure that the class will only be loaded if your module is actually imported by another module. Like so:

```
interface LogHandler {
    log(message: string);
}

@moduleScoped("my_namespace.app")
@tag("LogHandler")
@injectable()
class FileLogHandler implements LogHandler {
    log(message: string) {
        // save the message to a file
    }
}

@moduleScoped("my_namespace.app")
@tag("LogHandler")
@injectable()
class ConsoleLogHandler implements LogHandler {
    log(message: string) {
        console.log(message);
    }
}

@injectable()
class Logger {
    constructor(@injectAll("LogHandler") private readonly logHandlers: LogHandlerInterface[]) {} // <-- It would be nice to be able to have all the classes that implement LogHandler 
}

```

We'll explain the modules in the next chapter but for now, just assume that when you use the `@tag` decorator, also use the `@moduleScoped`. 

---

<p align="right">
    <strong>Next section: </strong> <a href="04.decorators.md">Decorators</a>
</p>

