<p>
   <strong>Previous section: </strong> <a href="docs/getting-started/01-overview/03.decorators.md">Decorators</a>
</p>


Modules
-------

Modules are a great way to structure your code such that you can bundle together code that serve a similar purpose. The Pristine framework follows this approach and as you can see, the code is decomposed in different modules. This brings better readability, better decoupling but most importantly, it keeps everything light. 

This allows us to lower the number of dependencies for projects that don't require all the features. You can simply import the modules you need and only the absolutely required dependencies will be installed.

## How to create your own module
As it's been said, Modules are a great way to organize your code. Pristine provides a lot of modules so that you can decide to import only the modules that you require for what you are building.

This also means that you can create your own Modules. This can be very useful if you have modules that you want to share between microservices or if you want to expose functionalities for other Pristine developers. 

### Create your module file

The first step, is to create your module file. Contrary to the `app.module.ts` file you created previously, a module file only needs to implement the `ModuleInterface`.

> Side note, you might not have noticed before, but the `AppModuleInterface` inherits from `ModuleInterface`. So yes, the `app.module.ts` is also a module but contains properties required to succesfully start the application. 

The ModuleInterface file has a few properties that can be defined. We'll go over them one by one.

#### Keyname (Must be provided)
The `keyname` property must be provided. They `keyname` property is used by Pristine to uniquely identify your module and prevent it from being loaded twice (that's the main use for now).

#### Configuration Definitions
To get familiar with Configuration and how it works in Pristine, it's recommended to read thoroughly the chapter on configuration. For the sake of brevity here, only a general explanation will be given.

Pristine allows you to pass configuration at runtime and resolve the values via the container. This allows you to nicely have your configuration values be injected in your classes. 

To ensure that a configuration doesn't go missing, Pristine allows a module to specify the configuration value it is expecting. This provides a nice level of protection as your module won't start if the configuration value isn't present.

> This is a nice feature since you don't need to E2E tests all your calls to see if a parameter is missing. You know directly when starting your application.

This is where the concept of Configuration Definition comes into play. In your module file, you can define multiple configuration definitions that will be interpreted by Pristine as described just above.

To learn more about Configuration, read the [Configuration](../../../packages/configuration/readme.md)  chapter.

#### Import Modules
In this property, you can list the modules that your module depends on. Pristine will automatically load the modules without any dependencies first so you can be certain that the dependencies that your module need will be loaded before yours.

Simply list the modules like this:

```
import {CoreModule} from "@pristine-ts/core";

...
importModules: [CoreModule],
...

```

#### Provider registrations
This property allows you to register your services that need special treatments to be instantiated. It uses the same syntax as the tsyringe providers so this is almost kind of a passthrough.

[Read more on tsyringe providers to know how to use them.](https://github.com/microsoft/tsyringe#providers)

#### `onInit` method
The `onInit` method is called during the initialization of your module and has the container as an argument so it can be used already. Be careful,
not everything will be created at this point and all the classes in your module will probably not be loaded. Tags and the Router will not have been loaded either.


#### `afterInit` method
The `onInit` method is called just after the initialization of your module and has the container as an argument so it can be used already. Be careful,
not everything will be created at this point and all the classes in your module will probably not be loaded. Tags and the Router will not have been loaded either.

### Import your modules
Once your module is properly created, you can then import it in your `app.module.ts` file and you will see that all the services it exports are now available.

## Official Pristine Modules
This section presents all the modules and gives brief information about what they contain.

The driving force behind Pristine is this idea that we are making the developers' lives easier. We will create a lot of modules that makes it very easy to integrate with different proprietary software.

 * [Auth0](../../../packages/auth0/readme.md) 
 * [AWS](../../../packages/aws/readme.md) 
 * [AWS Cognito](../../../packages/aws-cognito/readme.md) 
 * [AWS Scheduling](../../../packages/aws-scheduling/readme.md) 
 * [AWS XRay](../../../packages/aws-xray/readme.md) 
 * [Common](../../../packages//readme.md) 
 * [Configuration](../../../packages/configuration/readme.md) 
 * [Core](../../../packages/core/readme.md) 
 * [Event](../../../packages/event/readme.md) 
 * [Express](../../../packages/express/readme.md) 
 * [Http](../../../packages/http/readme.md) 
 * [Jwt](../../../packages/jwt/readme.md) 
 * [Logging](../../../packages/logging/readme.md) 
 * [Networking](../../../packages/networking/readme.md) 
 * [Redis](../../../packages/redis/readme.md) 
 * [Scheduling](../../../packages/scheduling/readme.md) 
 * [Security](../../../packages/security/readme.md) 
 * [Sentry](../../../packages/sentry/readme.md) 
 * [Stripe](../../../packages/stripe/readme.md) 
 * [Telemetry](../../../packages/telemetry/readme.md) 
 * [Validation](../../../packages/validation/readme.md) 

---

<p align="right">
    <strong>Next chapter: </strong> <a href="../02-controllers/00.index.md">Controllers</a>
</p>

